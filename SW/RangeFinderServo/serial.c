/**
 *  @file serial.c
 *  @brief Simple RS232 management in polling, no interrupt.
 *  @author Stefano B.
 *  @version 01. beta
 *  @date July 2007
 *  @details This is capable to send or read a character from a RS232 port,
 *  using ony two I/O pins.
 *  No interrupt or timer required.
 *
 *  I/O Pin used on the MSP430F2012 for the serial
 *
 *  P1.0|-->LED (debug/generic) <br>
 *  P1.2|<-- Rs232 Rx           <br>
 *  P1.5|<-- Rs232 Tx           <br>
 *
 *  To avoid to remain stuck waiting a character, uncomment the 
 *  NOTSTOP define
 *  The BRATE indicate the Baud rate and the TX_OHEAD and RX_OHEAD must be
 *  calculated for the willing baud rate.
 *  For 9600 baud :
 *     BRATE     9600
 *     TX_OHEAD  355
 *     RX_OHEAD  355
 */

#include "msp430x20x2.h"

#define NOTSTOP

/*
 *  I/O PIN define
 *  This code NOT perform any kind of initialization, so the main code
 *  MUST set up correctly the I/O pins used
 */
#define RXDATA (unsigned char) (P1IN & BIT2) << 5

#define TESTSIGON  P1OUT |= BIT0
#define TESTSIGOFF P1OUT &= ~BIT0

#define TXDATAON   P1OUT |= BIT5
#define TXDATAOFF  P1OUT &= ~BIT5

/*
 *  Timing defines
*/
#ifndef XTAL
#define XTAL 16000000         /* System frequency - sync with main init */
#endif
/* Baud rate */
#ifndef BRATE
#define BRATE  9600
#endif

#define NULL_LOOP      9               /* cycles per null loop */
#define TX_OHEAD       359             /* overhead cycles per loop - 355 for 9600 */
#define RX_OHEAD       359             /* receiver overhead per loop - 355 for 9600 */

#ifdef NOTSTOP
static unsigned short RSTimeOut;
#endif

/**
 * wait_n_cycles
 * @brief Wait a number of cycles
 *
 * This function is waiting for a determined numer of cycles in order
 * to create a character delay.
 * A cycle is the time the internal/no operation loop is taking.
 * <p>
 * WARNING !
 *  What is follow is the "theory of the operation".
 *  The "real" value used to feed this function was obtained for direct
 *  measurement with an oscilloscope.
 *  Because the clock frequency is not exactly 16 Mhz, because is not easy
 *  to find the real time occouring for all the instructions, the value
 *  calculated in the following description, is little bit different from
 *  the real one
 * <p>
 * Theory of operation<br>
 * The cycle, on the MSP430F2012 with this function, approx. uses 5 CPU cycles
 * (see MSP430x2xx User Manual - par. 3.4.4 Instruction Cycles and Lengths)
 * The calculation for the delay was done looking the disassembly of the
 * code generated by the IAR.
 *
 * Adding the function call (2 cycles) and the load of the value prior the
 * function call (2 cycles) and the return (2 cycles), we have :
 *
 *  (2+2+2+(5 * times)) * CPU cycle time = 1 function cycle = delay
 *
 *  so knowing the delay to obtain, we can apply the formula :
 *
 *    ((delay/5) / CPU cycle time) - 6 = times
 *
 *  Of course an interrut can introduce more delay.
 *  At 16 Mhz clock, each CPU cycle is 62.5 nSec.
 *  so the minimum delay possible (1 times) is :
 *  6+(5 * 1) = 6+5 = 11 * 62.5 nSec = .68 uSec
 *  So for example to obtain a 104 uSec delay, we have to have :
 *    
 *  ((104 uSec/5) / 62.5 nSec) -6 =
 *     0.000104 / 5 = 0.00000208
 *     0.00000208 / 0.000000062 = 332.8
 *     332 - 6 = 326
 *
 * @param c  the number of cycles to wait 
 * @return None
 */
void
wait_n_cycles(short times)
{
/*   TESTSIGON;  */
   do
   {  
     /* NIX */
   }   
   while(--times);
/*   TESTSIGOFF; */
}

/**
 * putch
 * @brief Send a character on the RS232
 *
 * This function send a character (8 bits) using the RS232 protocol
 *
 * @param c  the character to send 
 * @return None
 */
void
putch(char c)
{
   unsigned short bitno;

   TXDATAOFF;			/* start bit */
   bitno = 12;
   do 
   {
      wait_n_cycles(TX_OHEAD);  /* Wait one bit time */

      if(c & 0x01)
        TXDATAON;
      else
        TXDATAOFF;

      c = (c >> 1) | 0x80;
   } while(--bitno);
}

/**
 * getch
 * @brief SoftUART receiving
 *
 * This function receive a character (8 bits) using the RS232 protocol,
 * in polling mode.
 *
 * @param None 
 * @return the received character, or 0 if NOTSTOP define is present
 *  and no characters were received.
 */
char
getch(void)
{
   unsigned char rc;
   unsigned char bitno;

#ifdef NOTSTOP   
   RSTimeOut=0x00FF;
#endif
   
   for(;;) 
   {
#ifdef NOTSTOP   
      while(RXDATA)
      {
         RSTimeOut--;
  	  if(RSTimeOut==0)
  	  {
            return(0);
         }
      
         continue;	/* wait for start bit */
      }

#else      
      while(RXDATA)
         continue;
#endif         
      wait_n_cycles(RX_OHEAD/2);  /* Wait half bit time */

      if(RXDATA)
         continue;	/* twas just noise */
      
      bitno = 8;
      rc = 0;
      do
      {
         wait_n_cycles(RX_OHEAD);  /* Wait a bit time */
         rc = (rc >> 1) | RXDATA;
      } while(--bitno);
	
      return(rc);
   }
}

/**
 * getche
 * @brief SoftUART receiving with echo
 *
 * This function receive a character (8 bits) using the RS232 protocol,
 * in polling mode.
 * If a character is received, before to return it, it will be retransmitted
 * over the TX Rs232 pin.
 *
 * @param None 
 * @return the received character, or 0 if NOTSTOP define is present
 *  and no characters were received.
 */
char
getche(void)
{
   char c;

/*    TESTSIGOFF;  */
   
   c=getch();
   putch(c);
   return(c);
}

			




